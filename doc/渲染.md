# 渲染相关笔记

## PBR过程

基于物理的渲染过程，最常用的渲染过程，核心思想是光线的能量守恒，主要处理入射光线=反射+漫反射这一守恒。可参照[这篇文章](https://www.jianshu.com/p/d2c97d0646d5?open_source=weibo_search)。

## Encoding

Threejs默认的是线性色彩空间，而这个是数据均匀的色彩空间，但是对于人眼的感知来说，这种分布并不均匀，所以大多数显示器都采用sRGB的色彩空间，但是为了渲染效率，Threejs中模拟sRGB的曲线使用的是Gamma2.2的曲线，十分接近sRGB。

有[这篇](https://www.donmccurdy.com/2020/06/17/color-management-in-threejs/)和[这篇](https://medium.com/game-dev-daily/the-srgb-learning-curve-773b7f68cf7a)文章可以更深入理解。

其中提到了最佳实践：


> Best practices  
> 1. Textures with color data (.map, .emissiveMap, etc.) should be configured with .encoding = sRGBEncoding; all other textures use LinearEncoding.  
> 2. Vertex colors should be stored in linear colorspace.  
> 3. Material .color and .emissive should also use linear colorspace. Notably, this means that if you're trying to match an object in the scene to a #4285F4 color in your HTML/CSS, the material actually needs to be material.color.setHex( 0x4285f4 ).convertSRGBToLinear(). Same goes for light colors. Scene background color and fog color might be exceptions?  
> 4. Renderer should have .outputEncoding = sRGBEncoding if no post-processing is used, otherwise use LinearEncoding and apply gamma correction (TBD) as last pass in post instead.

这里能看到`THREE.GLTFLoader`其实完成了1，2，3步，所以如果使用GLTF模型，可以直接做第4步。

所以总结下来就是：

1. 纹理使用sRBG空间
2. 顶点色使用线性空间
3. 直接赋予的颜色属性，例如color/emissive，都使用线性空间。
4. 任何其他map，包括法线等map，都使用线性空间，否则会造成信息表达错误。

## 色调映射 tone mapping

这个技术主要是用来将颜色从高动态范围HDR隐射到低动态范围的函数，主要作用是模拟人眼和相机的视觉，人眼和相机能够呈现大于1的色调。

## 抗锯齿

Threejs的抗锯齿很简单，multi sampling(MSAA)，就是在物体边缘使用4格分割1像素，最终取平均，所以这种抗锯齿在pixel ratio为2以下时开启最好，否则效果不大。

```javascript
const renderer = new THREE.WebGLRenderer({
  canvas,
  antialias: window.devicePixelRatio === 1,
});
```

## 曲面阴影

不加处理的曲面通常会产生摩尔纹状的表面阴影，这是因为曲面在产生阴影时，自己对自己产生了阴影，具体原因是在光线的阴影相机产生阴影判定的时候，是阴影像素对应于模型是一块面积，具体可以参照[这篇](https://www.zhihu.com/question/49090321)文章。

解决这一问题可以通过对光线施加`bias`和`normalBias`。前者多用于平面，后者多用于曲面。

bias的作用是使得光线在判定的时候，内缩若干值，这样就能减少shadow acne现象，但是随着bias增大，副作用是阴影会略微偏离模型，产生一定的失真。
